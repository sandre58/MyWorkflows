name: 'Detect Project Type'
description: 'Analyze a .NET project file to determine if it should be packed as a NuGet package or published as an application'
author: 'sandre58'

inputs:
  project-path:
    description: 'Path to the .csproj file'
    required: true

outputs:
  project-type:
    description: 'Type of project: "library" for NuGet packages, "application" for publishable apps'
    value: ${{ steps.detect.outputs.project-type }}
  is-packable:
    description: 'Whether the project can be packed as NuGet (true/false)'
    value: ${{ steps.detect.outputs.is-packable }}
  is-publishable:
    description: 'Whether the project can be published as an application (true/false)'
    value: ${{ steps.detect.outputs.is-publishable }}
  output-type:
    description: 'OutputType from the project file (Exe, WinExe, Library, etc.)'
    value: ${{ steps.detect.outputs.output-type }}
  target-framework:
    description: 'Target framework of the project'
    value: ${{ steps.detect.outputs.target-framework }}

runs:
  using: 'composite'
  steps:
    - name: Detect project type
      id: detect
      shell: bash
      run: |
        csproj_file="${{ inputs.project-path }}"
        
        if [[ ! -f "$csproj_file" ]]; then
          echo "Error: Project file not found: $csproj_file"
          exit 1
        fi
        
        echo "Analyzing project file: $csproj_file"
        
        # Function to search for property in hierarchy (Directory.Build.props, then .csproj)
        find_property() {
          local property_name="$1"
          local project_dir="$(dirname "$csproj_file")"
          local current_dir="$project_dir"
          local value=""
          
          # Search in Directory.Build.props files from project dir up to root
          while [[ "$current_dir" != "/" && "$current_dir" != "" ]]; do
            local build_props="$current_dir/Directory.Build.props"
            if [[ -f "$build_props" ]]; then
              echo "Checking $build_props for $property_name"
              value=$(grep -o "<$property_name>[^<]*</$property_name>" "$build_props" | sed 's/<[^>]*>//g' | head -1)
              if [[ -n "$value" ]]; then
                echo "Found $property_name in $build_props: $value"
                echo "$value"
                return
              fi
            fi
            current_dir="$(dirname "$current_dir")"
          done
          
          # If not found in Directory.Build.props, check the .csproj file
          value=$(grep -o "<$property_name>[^<]*</$property_name>" "$csproj_file" | sed 's/<[^>]*>//g' | head -1)
          if [[ -n "$value" ]]; then
            echo "Found $property_name in project file: $value"
            echo "$value"
          fi
        }
        
        # Extract properties using hierarchy
        output_type=$(find_property "OutputType")
        if [[ -z "$output_type" ]]; then
          output_type="Library"  # Default if not specified
        fi
        echo "Final OutputType: $output_type"
        
        # Extract TargetFramework(s)
        target_framework=$(find_property "TargetFramework")
        if [[ -z "$target_framework" ]]; then
          target_frameworks=$(find_property "TargetFrameworks")
          if [[ -n "$target_frameworks" ]]; then
            # Take the first value if multiple frameworks are present
            target_framework=$(echo "$target_frameworks" | cut -d';' -f1)
          fi
        fi
        echo "Final TargetFramework: $target_framework"
        
        # Check IsPackable property
        is_packable_prop=$(find_property "IsPackable")
        echo "Final IsPackable: $is_packable_prop"
        
        # Determine project type based on analysis
        project_type="library"
        is_packable="true"
        is_publishable="false"
        
        # Check if it's an executable (application)
        if [[ "$output_type" == "Exe" || "$output_type" == "WinExe" ]]; then
          project_type="application"
          is_packable="false"
          is_publishable="true"
          echo "Detected executable project (OutputType: $output_type)"
        fi
        
        # Check explicit IsPackable setting
        if [[ "$is_packable_prop" == "false" ]]; then
          project_type="application"
          is_packable="false"
          is_publishable="true"
          echo "Detected non-packable project (IsPackable: false)"
        elif [[ "$is_packable_prop" == "true" ]]; then
          project_type="library"
          is_packable="true"
          is_publishable="false"
          echo "Detected packable project (IsPackable: true)"
        fi
        
        # Check for web applications (usually publishable, not packable)
        if grep -q '<Project Sdk="Microsoft\.NET\.Sdk\.Web">' "$csproj_file"; then
          project_type="application"
          is_packable="false"
          is_publishable="true"
          echo "Detected web application (SDK: Microsoft.NET.Sdk.Web)"
        fi
        
        # Check for worker services (usually publishable, not packable)
        if grep -q '<Project Sdk="Microsoft\.NET\.Sdk\.Worker">' "$csproj_file"; then
          project_type="application"
          is_packable="false"
          is_publishable="true"
          echo "Detected worker service (SDK: Microsoft.NET.Sdk.Worker)"
        fi
        
        # Special case: if it has PackageReference but no executable output, likely a library
        if [[ "$output_type" == "Library" ]] && grep -q '<PackageReference' "$csproj_file"; then
          project_type="library"
          is_packable="true"
          is_publishable="false"
          echo "Detected library project with package references"
        fi
        
        echo "Final determination:"
        echo "  Project Type: $project_type"
        echo "  Is Packable: $is_packable"
        echo "  Is Publishable: $is_publishable"
        echo "  Output Type: $output_type"
        echo "  Target Framework: $target_framework"
        
        # Set outputs
        echo "project-type=$project_type" >> $GITHUB_OUTPUT
        echo "is-packable=$is_packable" >> $GITHUB_OUTPUT
        echo "is-publishable=$is_publishable" >> $GITHUB_OUTPUT
        echo "output-type=$output_type" >> $GITHUB_OUTPUT
        echo "target-framework=$target_framework" >> $GITHUB_OUTPUT